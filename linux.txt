########################################
# ///////// LINUX BASH SHELL \\\\\\\\\ #
########################################

################        ################
#! /bin/bash   #        #   20171109   #
################        ################

################################################################################
000={INTRODUCTION}
################################################################################
#------------------------------------------------------------------------------#
000:001={ATTRIBUTION}
#------------------------------------------------------------------------------#
000:001:001={UPDATED}
# 20171109
000:001:002={CREDITS}
# h8rt3rmin8r
# 161803398@email.tg
000:001:003={PUBKEY}
# "http://h8rt3rmin8r.com"
000:001:004={SOURCE}
# "http://h8rt3rmin8r.com/linux"
#------------------------------------------------------------------------------#
000:002={SYNTAX}
#------------------------------------------------------------------------------#
# Each section and attribute of this document is clearly marked in the following ways:
000:002:001={SERIES1 TITLES}
# Series1 Titles begin in the form of "111=" where "111" is the numeric tag.
# The label of the Series1 Title is in all-caps and enclosed in curly braces.
000:002:002={SERIES2 TITLES}
# Series2 Titles begin in the form of "111:222=" where "111" is the numeric tag of the parent Series1 Title, and "222" is the numeric tag of the Series2 Title.
# The label of the Series2 Title is in all-caps and enclosed in curly braces.
000:002:003={SERIES3 TITLES}
# Series3 Titles begin in the form of "111:222:333=" where "111" is the numeric tag of the parent Series1 Title, and "222" is the numeric tag of the parent Series2 Title, and "333" is the numeric tag of the Series3 Title.
# The label of the Series3 Title is in all-caps and enclosed in curly braces.
000:002:004={SERIES4 TITLES}
# Series4 Titles begin in the form of "111:222:333:444=" where "111" is the numeric tag of the parent Series1 Title, and "222" is the numeric tag of the parent Series2 Title, and "333" is the numeric tag of the Series3 Title, and "444" is the numeric tag of the Series4 Title.
# The label of the Series4 Title is in all-caps and enclosed in curly braces.
000:002:005={INPUT}
# All terminal commands are written with no indentation and no preceding symbols
# OPTIONAL: Terminal command inputs may be distinguished by "{INPUT}: ". This is often used when explaining command syntax.
#-> (Example): {INPUT}: cp ~/Documents/MyFile1.txt ~/Documents/MyFile2.txt
000:002:006={OUTPUT}
# Resulting terminal outputs are indicated by the "{OUTPUT}: " flag followed by the appropriate output
#-> (Example): {OUTPUT}: Process complete!
000:002:007={URL}
# Universal Resource Locators ("URLs" or "links") which are included for reference purposes and which are not part of a Terminal {INPUT} may be flagged with the {URL} tag and followed by the appropriate website link enclosed inside double quotation marks. Alternatively, URLs may be passed as a textual comment by placing them on a line which begins with "#" and enclosing the URL in quotation marks.
#-> (Example #1): {URL}: "https://example.com"
#-> (Example #2): # "https://example.com"
000:002:008={LIST ITEMS}
# List items begin with "#->" and include indentation when necessary
# First level nested items of a list begin with "#--->"
# Second level nested items of a list begin with "#----->"
# Third level nested items of a list begin with "#------->"
# Every indentation is given another four dashes ("--") which act as a "tab" in this way.
000:002:009={#}
# The hashtag symbol "#" is used to flag the presence of text and comments.
# This same symbol can be used to indicate a line break as well so as to improve readability.
# Terminal commands will never occur on a line starting with "#" except when flagged by the {INPUT} flag
000:002:010={[]}
# Square braces "[" and "]" are used to enclose the contents of various sections and/or examples.
#------------------------------------------------------------------------------#
000:003={CONTENTS}
#------------------------------------------------------------------------------#
[
#---------------------------------------------------#
# 000={INTRODUCTION}
#---------------------------------------------------#
# 000:001={ATTRIBUTION}
# 000:002={SYNTAX}
# 000:003={CONTENTS}
#---------------------------------------------------#
# 001={ESSENTIAL NAVIGATION}
#---------------------------------------------------#
# 001:001={LISTING FILES AND FOLDER CONTENTS}
# 001:002={FIND OUT WHERE YOU ARE}
# 001:003={FIND OUT WHO YOU ARE}
# 001:004={COPYING FILES}
# 001:005={MOVING AND RENAMING FILES}
# 001:006={DELETING FILES}
# 001:007={FINDING FILES}
# 001:008={MAKING NEW FILES}
# 001:009={MAKING NEW DOCUMENTS}
# 001:010={EDITING DOCUMENTS}
# 001:011={PRINTING FILE CONTENTS}
# 001:012={COUNT FILE WORDS LINES AND CHARACTERS}
# 001:013={EXTRACTING ARCHIVES}
# 001:014={UPDATE THE SYSTEM PACKAGE LIST}
# 001:015={UPDATE YOUR LINUX OPERATING SYSTEM}
# 001:016={DISPLAY THE SYSTEM DATE AND TIME}
# 001:017={}
# 001:018={}
# 001:019={}
# 001:020={}
# 001:021={}
# 001:022={}
# 001:023={}
# 001:024={}
# 001:025={}
# 001:026={}
#---------------------------------------------------#
# 002={TOOLS AND FUNCTIONS}
#---------------------------------------------------#
# 002:001={A}
# 002:002={B}
# 002:003={C}
# 002:004={D}
# 002:005={E}
# 002:006={F}
# 002:007={G}
# 002:008={H}
# 002:009={I}
# 002:010={J}
# 002:011={K}
# 002:012={L}
# 002:013={M}
# 002:014={N}
# 002:015={O}
# 002:016={P}
# 002:017={Q}
# 002:018={R}
# 002:019={S}
# 002:020={T}
# 002:021={U}
# 002:022={V}
# 002:023={W}
# 002:024={X}
# 002:025={Y}
# 002:026={Z}
#---------------------------------------------------#
# 003={SYSTEM ADMINISTRATION AND EXPLOITATION}
#---------------------------------------------------#
# 003:001={PERMISSIONS AND USER ACCESS}
# 003:002={SYNCRONIZE ONE DIRECTORY WITH ANOTHER}
# 003:003={VIEW ALL RUNNING PROCESSES}
# 003:004={LIST SYSTEM HARDWARE}
# 003:005={SCHEDULING TASKS WITH CRON}
# 003:006={CHECK YOUR IP ADDRESS}
# 003:007={NETWORK CONNECTIONS}
# 003:008={NETWORK AND PORT MAPPING}
# 003:009={SECURE SHELL FOR REMOTE ACCESS}
# 003:010={DISPLAY LOCAL DNS INFORMATION}
# 003:011={DISPLAY LOCAL GATEWAY INFORMATION}
# 003:012={}
# 003:013={}
# 003:014={}
# 003:015={}
# 003:016={}
# 003:017={}
# 003:018={}
# 003:019={}
# 003:020={}
# 003:021={}
# 003:022={}
# 003:023={}
# 003:024={}
# 003:025={}
# 003:026={}
#---------------------------------------------------#
# 004={FRAMEWORKS AND LIBRARIES}
#---------------------------------------------------#
# 004:001={WORKING WITH PPAs}
# 004:002={BUILDING AND USING SHELL SCRIPTS}
# 004:003={PROGRAM CROSS-PLATFORM SOFTWARE WITH MONO}
# 004:004={VISUALIZE DATA WITH GRAPHVIZ-DEV}
# 004:005={NODE.JS AND NODE PACKAGE MANAGER}
# 004:006={}
# 004:007={}
# 004:008={}
# 004:009={}
# 004:010={}
# 004:011={}
# 004:012={}
# 004:013={}
# 004:014={}
# 004:015={}
# 004:016={}
# 004:017={}
# 004:018={}
# 004:019={}
# 004:020={}
# 004:021={}
# 004:022={}
# 004:023={}
# 004:024={}
# 004:025={}
# 004:026={}
#---------------------------------------------------#
# 005={CRYPTOGRAPHY}
#---------------------------------------------------#
# 005:001={GENERATE AND MANAGE AN IDENTITY}
# 005:002={}
# 005:003={}
# 005:004={}
# 005:005={}
# 005:006={}
# 005:007={}
# 005:008={}
# 005:009={}
# 005:010={}
# 005:011={}
# 005:012={}
# 005:013={}
# 005:014={}
# 005:015={}
# 005:016={}
# 005:017={}
# 005:018={}
# 005:019={}
# 005:020={}
# 005:021={}
# 005:022={}
# 005:023={}
# 005:024={}
# 005:025={}
# 005:026={}
#---------------------------------------------------#
# 006={WORKING WITH BLOCKCHAIN}
#---------------------------------------------------#
# 006:001={CHECK THE CURRENT BITCOIN PRICE}
# 006:002={OTHER USEFUL CRYPTOCURRENCY APIS}
# 006:003={}
# 006:004={}
# 006:005={}
# 006:006={}
# 006:007={}
# 006:008={}
# 006:009={}
# 006:010={}
# 006:011={}
# 006:012={}
# 006:013={}
# 006:014={}
# 006:015={}
# 006:016={}
# 006:017={}
# 006:018={}
# 006:019={}
# 006:020={}
# 006:021={}
# 006:022={}
# 006:023={}
# 006:024={}
# 006:025={}
# 006:026={}
]
#------------------------------------------------------------------------------#
################################################################################
001={ESSENTIAL NAVIGATION}
################################################################################
#------------------------------------------------------------------------------#
001:001={LISTING FILES AND FOLDER CONTENTS}
# View all files and folders in your current directory
ls
# View all files and folders in your current directory and INCLUDE hidden files:
ls -a
# View all files and folders in your current directory and INCLUDE file ownership and last-updated information in the output:
ls -l
#------------------------------------------------------------------------------#
001:002={FIND OUT WHERE YOU ARE}
# Print the name of the current/working directory
pwd
#------------------------------------------------------------------------------#
001:003={FIND OUT WHO YOU ARE}
# Print the name of the user that you are currently controling
whoami
#------------------------------------------------------------------------------#
001:004={COPYING FILES}
# Copy files and folders using "cp"
# Basic syntax is as follows:
{INPUT}: cp [Target to be coppied] [Destination]
# The following command would copy "MyDocument.txt" from your user Downloads folder onto "MyDocument.txt" in your user Documents folder:
cp ~/Downloads/MyDocument.txt ~/Documents/MyNewFolder/MyDocument.txt
# NOTE: You don't have to make "MyDocument.txt" inside your Documents folder before using the cp command. The cp command will create the new file automatically.
#------------------------------------------------------------------------------#
001:005={MOVING AND RENAMING FILES}
# Moving and renaming files are considered the same exact function since, on a basic level, they 
# are the same (renaming is nothing more than moving data from one file name to another file name).
# Basic syntax is as follows:
{INPUT}: mv [The file to move] [Location to move the file into]
# The following example shows how to move a text document called "MY-DOC.txt" from the Downloads
# folder into the Documents folder:
mv ~/Downloads/MyDocument.txt ~/Documents/MyNewFolder/MyDocument.txt
# As stated previously, moving and renaming files is the same process. Below is an example:
mv ~/Documents/MyNewFolder/My-Old-Document.txt ~/home/user/My-New-Document.txt
#------------------------------------------------------------------------------#
001:006={DELETING FILES}
# Delete, or "remove" files with the "rm" tool

001:006:001={GENERAL FORMATTING AND SYNTAX}
rm [-f|i|I|q|R|r|v] [file]
# rm removes a file if you specify a correct path for it 
# Sometimes you may not have the write permissions for a file, in that case it asks 
# you for confirmation. Type yes if you want to delete it.

001:006:001={OPTIONS FOR rm}
-f
# Deletes read-only files immediately without any confirmation. If both -f and -i are used then the one which appears last in the terminal is used by rm.
-i
# Prompts for confirmation before deleting every file before entering a sub-directory if used with -R or -r. If both -f and -i are used then the one which appears last in the terminal is used by rm.
-q
# Suppresses all the warning messages however error messages are still displayed. However the exit status is modified in case of any errors.
-R
# Delete recursively. It is used to delete the directory tree starting at the directory specified i.e. it deletes the specified directory along with its sub-directory and files.
-r
# The same as -R.
-v
# Displays the file names on the output as they are being processed.
-I
# Prompts every time when an attempt is made to delete for than 3 files at a time or while removing recursively. 

001:006:001={IMPORTANT PRECAUTIONS}
# Never type the following command into a terminal:
sudo rm -R / 
# or 
sudo rm -r / 
# as it deletes all the data in the root directory and will delete the data of all the mounted volumes until you want to wipe of everything from your system.
# Another command to avoid using is:
sudo rm -f /*

001:006:001={ADDITIONAL NOTES}
# It is possible to recover files deleted through rm
# If you want to permanently delete a file use the command:
shred

#------------------------------------------------------------------------------#
001:007={FINDING FILES}
# The following command shows how you would look for a file named "MyFile":
whereis MyFile
#------------------------------------------------------------------------------#
001:008={MAKING NEW FOLDERS}
# The following command will create a new folder named "MyNewFolder" in your current directory:
mkdir MyNewFolder
# You can also create a folder in a different directory by specifying the exact path to the new directory you want to create:
mkdir ~/Documents/MyNewFolder
#------------------------------------------------------------------------------#
001:009={MAKING NEW DOCUMENTS}
# There are many ways to create a new document and there are countless types of documents that you could create.
# To create a simple text document named "MyDocument.txt" simply invoke the nano text editor like this:
nano MyDocument.txt
# You will then be inside of the new document and can begin to compose the text.
# To exit nano editor, simply press [CONTROL]+[x]. You will be asked if you want to save the new text you just typed. Indicate "yes" by pressing the letter [Y] and press [ENTER] when asked about the new document name.
#------------------------------------------------------------------------------#
001:010={EDITING DOCUMENTS}
# To edit most types of script files and text files, simply use nano:
nano MyDocument.txt
# Edit a document that is located in a different directory like this:
nano ~/Documents/MyNewFolder/MyDocument.txt
#------------------------------------------------------------------------------#
001:011={PRINTING FILE CONTENTS}
# Concatenate and/or print the contents of a file named "MyFile.txt" in the terminal:
cat MyFile.txt
# You can number all output lines with the -n flag like this:
cat -n myText.txt
#------------------------------------------------------------------------------#
001:012={COUNT FILE WORDS LINES AND CHARACTERS}
# The "wc" program is excellent for comparing versions of files, among other things.
# To search a text document named "awesome.txt" with this tool, run the following command:
wc awesome.txt
# The output will include three number sets which correspond to the following:
{OUTPUT}: [# of new lines] [# of words] [# of characters]
# To learn more about this tool, read the documentation at the following location: 
{URL}: "http://manpages.ubuntu.com/manpages/trusty/man1/wc.1.html"
#------------------------------------------------------------------------------#
001:013={EXTRACTING ARCHIVES}

001:013:001={TAR}
# Unpack .xz and .tgz archives with tar
# Most packages can be unpacked using the "-xf" flag with tar like this:
tar -xf ARCHIVE.tar.xz
# Unpack the .gzip and .bzip2 archive types with the tar command:
tar -xfz ARCHIVE.gzip
tar -xfz ARCHIVE.bzip2
# The -xf flag works with a large number of compression types. So basically, if in doubt, just use the -xf flag with tar.
# NOTE: Make sure that you have the additional utilities installed for tar (xz-utils).
# You can install the xz-utils with the following command: 
sudo apt-get install xz-utils

001:013:002={ZIP}

001:013:003={RAR}
# Unpack a .rar archive with the "unrar" tool. First install it with the following command:
sudo apt-get install unrar-free
# Now unpack the archive (Example archive named: "ARCHIVE.rar") with this command:
unrar e ARCHIVE.rar

#------------------------------------------------------------------------------#
001:014={UPDATE THE SYSTEM PACKAGE LIST}
# Run this command after installing new software on your system and before attempting to update your Linux machine's OS:
sudo apt-get update
#------------------------------------------------------------------------------#
001:015={UPDATE YOUR LINUX OPERATING SYSTEM}
# Perform a system "upgrade" at least once every week. This ensures that you are running the latest versions of software:
sudo apt-get dist-upgrade
# NOTE: Always perform a system update FIRST (See 001:014)
#------------------------------------------------------------------------------#
001:016={DISPLAY THE SYSTEM DATE AND TIME}
# Display the system date in the terminal with the following command:
date
{OUTPUT}: Mon Oct  9 03:45:19 UTC 2017
# Formatting the date can be accomplished in the following ways:
#-> EXAMPLE 1
date '+%Y%m%d'
{OUTPUT}: 20171009
#-> EXAMPLE 2
date '+%Y-%m-%d'
{OUTPUT}: 2017-10-09
#-> EXAMPLE 3
date '+%Y-%m-%d-%H-%M-%S'
{OUTPUT}: 2017-10-09-03-45-19
#-> EXAMPLE 4
date '+%Y%m%d-%H%M%S'
{OUTPUT}: 20171009-034601
#------------------------------------------------------------------------------#
001:017={}
#------------------------------------------------------------------------------#
001:018={}
#------------------------------------------------------------------------------#
001:019={}
#------------------------------------------------------------------------------#
001:020={}
#------------------------------------------------------------------------------#
001:021={}
#------------------------------------------------------------------------------#
001:022={}
#------------------------------------------------------------------------------#
001:023={}
#------------------------------------------------------------------------------#
001:024={}
#------------------------------------------------------------------------------#
001:025={}
#------------------------------------------------------------------------------#
001:026={}
#------------------------------------------------------------------------------#
################################################################################
002={TOOLS AND FUNCTIONS}
################################################################################
#------------------------------------------------------------------------------#
002:001={A}

002:001={A}-[ arp-scan ]
# Full network analysis tool to see what IPs are connected to the local network
# Install with the following
sudo apt-get install arp-scan
# Run a scan on the local network with the following command:
sudo arp-scan --localnet
# If connected to the local network via multiple network interfaces or connections, specify the
# one you wish to use for the arp-scan with the --interface flag like this:
sudo arp-scan --interface=eth0 --localnet
# To discover which interface you are using to interact with the local network
# run the following command
ifconfig
# Learn more about the arp-scan tool at the following address: 
firefox http://manpages.ubuntu.com/manpages/zesty/en/man1/arp-scan.1.html

#------------------------------------------------------------------------------#
002:002={B}
#------------------------------------------------------------------------------#
002:003={C}

002:003={C}-[ cat ]
# Concatenate and/or print the contents of a file named "MyFile.txt" in the terminal:
cat MyFile.txt
# You can number all output lines with the -n flag like this:
cat -n myText.txt

002:003={C}-[ cp ]
# Copy files and folders using "cp"
# Basic syntax is as follows:
{INPUT}: cp [Target to be coppied] [Destination]
# The following command would copy "MyDocument.txt" from your user Downloads folder onto "MyDocument.txt" in your user Documents folder:
cp ~/Downloads/MyDocument.txt ~/Documents/MyNewFolder/MyDocument.txt
# NOTE: You don't have to make "MyDocument.txt" inside your Documents folder before using the cp command. The cp command will create the new file automatically.

002:003={c}-[ cron ]
# cron is the tool which automates things for you
# crontab is the tool which dictates the actions of cron (for each system user)
# List the contents of the crontab file (if contents exist):
crontab -l
# Edit the contents of the crontab file:
crontab -e
# Remove the contents of the crontab file:
crontab -r
# Edit the contents of a DIFFERENT user's crontab file (where "OTHERUSER" is the username of the user whose crontab file you will be editing):
crontab -e -u OTHERUSER
# Please note that you must be an administrative user to edit the crontab files of other users.
# The crontab file contains entries which describe the processes to be automated. These entries each begin with FIVE specific elements of TIME:
> (MINUTE): 0-59
> (HOUR): 0-23 with 0 being 12:00 AM
> (DAY OF THE MONTH): 1-31
> (MONTH): 1-12
> (DAY OF THE WEEK): 0-6 with 0 being Sunday
# Below is a series of example crontab entry time codes with corresponding definitions:
# Daily at 11:00 PM
0 23 * * *
# Daily at 10:30 PM
30 22 * * *
# Every first day of the month at 11 PM
0 23 1 * *
# Every Sunday at 11PM
0 23 * * 0
# The FreeBSD implementation of cron introduced the useful shortcuts which can be used instead of the afforementioned FIVE-part time elements. These shortcuts are listed below:
#-> @reboot (Run once, at startup of cron)
#-> @yearly (Run once a year, "0 0 1 1 *")
#-> @annually (same as @yearly)
#-> @monthly (Run once a month, "0 0 1 * *")
#-> @weekly (Run once a week, "0 0 * * 0")
#-> @daily (Run once a day, "0 0 * * *")
#-> @midnight (same as @daily)
#-> @hourly (Run once an hour, "0	* * * *")
#-> @every_minute (Run once a minute, "*/1 * * * *")
#-> @every_second (Run once a second)
# To add a new automated process to cron, you must first select or create a shell script (a file ending in  .sh) which contains the instructions needed for the desired process. That script file will then be saved (as a hidden file so as to protect it). Make sure that your script is executable by running the following command: 
chmod u+x ~/.MyScript.sh
# Assuming you have a shell script with the name "MyScript.sh" located in your user's home directory, you could run this script in cron by adding the following entry to crontab:
0 23 * * * ~/.MyScript.sh

002:003={C}-[ cut ]
# Remove sections from each line of specific files or inputs/outputs
# The basic command syntax for "cut" must specify a target input file if "cut" is not being used as the target of a previous command.
# Use case: to output the last modified date/time of a specific file named "myFile.txt":
ls -l myFile.txt | cut -d ' ' -f '6-8'
{OUTPUT}: Jul 26 15:05
# Looking closer at this command, notice that the output of "ls -l myFile.txt" is the following:
ls -l myFile.txt
{OUTPUT}: -rw-rw-r-- 1 $username $username 2 Jul 26 15:05 myFile.txt
# This output is then piped into "cut" (by using the "|" symbol) and "cut" performs the following:
#-> -d ' '
# The output of ls -l is split at every space as a delimiter resulting in 9 fields
#-> -f '6-8'
# Fields #6-#8 are retained, eliminating all other fields

#------------------------------------------------------------------------------#
002:004={D}

002:004={D}-[ date ]
# Display the system date in the terminal with the following command:
date
{OUTPUT}: Mon Oct  9 03:45:19 UTC 2017
# Formatting the date can be accomplished in the following ways:
#-> EXAMPLE 1
date '+%Y%m%d'
{OUTPUT}: 20171009
#-> EXAMPLE 2
date '+%Y-%m-%d'
{OUTPUT}: 2017-10-09
#-> EXAMPLE 3
date '+%Y-%m-%d-%H-%M-%S'
{OUTPUT}: 2017-10-09-03-45-19
#-> EXAMPLE 4
date '+%Y%m%d-%H%M%S'
{OUTPUT}: 20171009-034601

#------------------------------------------------------------------------------#
002:005={E}

002:005={E}-[ egrep ]
# egrep is an acronym for "Extended Global Regular Expressions Print". 
# It is a program which scans a specified file line by line, returning lines that contain a pattern matching a given regular expression.
# Example of proper syntax:
egrep <flags> '<regular expression>' <filename>
# The egrep differs from theoretical regex in that it processes strings by line where theoretical regex processes a string as the total target contents
# The symbol pair for word boundaries are \< and \> which respectively denote the beginning and ending of a word.
# To specify a set or range of characters use braces. 
[a9A05]
# To negate the set, use the hat symbol ^ as the first character.
[^a9A05]
# The set of all lowercase letters would be input as:
[a-z]
# To learn more, visit the following site:
{URL}: "http://www.cs.columbia.edu/~tal/3261/fall07/handout/egrep_mini-tutorial.htm"
# Below are some examples of egrep syntax along with their corresponding descriptions:
#-> Example-1
# Match all lines in searchfile.txt which start with a non-empty bitstring, followed by a space, followed by a non-empty alphabetic word which ends the line.
egrep '^(0|1)+ [a-zA-Z]+$' searchfile.txt
#-> Example-2
# Count the number of lines in lots_o_bits which either start with 1 or end with 01.
egrep -c '^1|01$' lots_o_bits
#-> Example-3
# Count the number of lines with at least eleven 1's.
egrep -c '10*10*10*10*10*10*10*10*10*10*1' lots_o_bits
#-> Example-4
# List all the lines in myletter.txt containing the word the insensitive of case.
egrep -i '\<the\>' myletter.txt

#------------------------------------------------------------------------------#
002:006={F}
#------------------------------------------------------------------------------#
002:007={G}

002:007={G}-[ gpg ]
# Encrypt, decrypt, sign, and verify a host of different items with this encryption tool
# Review the core functions with:
man gpg
# See also Section 005 (Cryptography)
 
#------------------------------------------------------------------------------#
002:008={H}

002:008={h}-[ htop ]
# Install htop with the following command:
sudo apt install htop
# Then run htop with the command:
htop
# You can kill/end processes graphically using htop! Simply refer to the options displayed
# at the bottom of the terminal screen

#------------------------------------------------------------------------------#
002:009={I}

002:009={I}-[ inxi ]
# The full system component explorer tool
# Install inxi with the following command
sudo apt-get install inxi
# Run inxi with the following command
inxi

#------------------------------------------------------------------------------#
002:010={J}

002:010={J}-[ jq ]
# jq is a command line JSON processor (very useful in processing API JAON data)
# Install with the following:
sudo apt-get install jq
# Syntax overview:
{INPUT}: jq [options...] filter [files...]
# Pipe JSON through jq to enforce pretty print like this:
curl https://bittrex.com/api/v1.1/public/getmarketsummaries | jq '.'
# Print the list of keys from a given file:
jq 'keys' 
# Print the values at keys "foo" and "bar":
jq '.foo, .bar'

#------------------------------------------------------------------------------#
002:011={K}
#------------------------------------------------------------------------------#
002:012={L}

002:012={L}-[ ls ]
# View all files and folders in your current directory
ls
# View all files and folders in your current directory and INCLUDE hidden files:
ls -a
# View all files and folders in your current directory and INCLUDE file ownership and last-updated information in the output:
ls -l

002:012={L}-[ lshw ]
# List all hardware installed on your system
# NOTE: You need to run this command with "sudo" permissions
sudo lshw

002:012={L}-[ lsof ]
# List Process IDs with corresponding port numbers and what external IP addresses are connected to them
lsof -i -P

002:012={L}-[ lynx ]
# lynx is a useful text-only terminal-based web browser
# (AFTER INSTALL) run lynx with the following command: 
lynx
# Dump all links from a single webpage with Lynx
lynx -listonly -dump url.example.com
# Output the result of the link list dump into a text file in your current directory
lynx -listonly -dump url.example.com | nano url.example.com.txt

#------------------------------------------------------------------------------#
002:013={M}

002:013={M}-[ mkdir ]
# The following command will create a new folder named "MyNewFolder" in your current directory:
mkdir MyNewFolder
# You can also create a folder in a different directory by specifying the exact path to the new directory you want to create:
mkdir ~/Documents/MyNewFolder

002:013={M}-[ mv ]
# Moving and renaming files are considered the same exact function since, on a basic level, they 
# are the same (renaming is nothing more than moving data from one file name to another file name).
# Basic syntax is as follows:
{INPUT}: mv [The file to move] [Location to move the file into]
# The following example shows how to move a text document called "MY-DOC.txt" from the Downloads
# folder into the Documents folder:
mv ~/Downloads/MyDocument.txt ~/Documents/MyNewFolder/MyDocument.txt
# As stated previously, moving and renaming files is the same process. Below is an example:
mv ~/Documents/MyNewFolder/My-Old-Document.txt ~/home/user/My-New-Document.txt

#------------------------------------------------------------------------------#
002:014={N}

002:014={N}-[ nano ]
# There are many ways to create a new document and there are countless types of documents that you could create.
# To create a simple text document named "MyDocument.txt" simply invoke the nano text editor like this:
nano MyDocument.txt
# You will then be inside of the new document and can begin to compose the text.
# To exit nano editor, simply press [CONTROL]+[x]. You will be asked if you want to save the new text you just typed. Indicate "yes" by pressing the letter [Y] and press [ENTER] when asked about the new document name.
# To edit most types of script files and text files, simply use nano:
nano MyDocument.txt
# Edit a document that is located in a different directory like this:
nano ~/Documents/MyNewFolder/MyDocument.txt

002:014={N}-[ netstat ]
# Get a general overview of the network status for your system
netstat
# List all active ports and connections (external)
netstat -tunlp
# List all active ports and connections (internal & external)
netstat -pln

002:014={N}-[ nmap ]
# (AFTER INSTALL) run nmap with the following command:
nmap
# Scan the open ports and status of a specific IP address (this example uses the IP address
# of 192.168.1.50 as an example) with the following command: 
nmap 192.168.1.50
# NOTE: In many jurisdictions it is illegal to scan the ports of systems which you don't control.
# Hackers are able to maintain a level of annonymity by spoofing their MAC address during a port
# scan by using the --spoof-mac flag like this:
nmap -spoof-mac 00:11:22:33:44:55 192.168.1.50
# By spoofing your MAC address you are able to assume the identity of another trusted
# computer on the target network (if you know the MAC address of any of the authorized computers)
# or, at the very least, you are able to distance yourself from using the true identity of your own
# computer. (The example above uses the false MAC address, 00:11:22:33:44:55).
# Output the results of your nmap scan to a text file ("scan.txt")
nmap -oN scan.txt 192.168.1.50
# Print the output to a text file while spoofing your MAC address:
nmap -spoof-mac 00:11:22:33:44:55 -oN scan.txt 192.168.1.50

#------------------------------------------------------------------------------#
002:015={O}
#------------------------------------------------------------------------------#
002:016={P}

002:016={P}-[ pwd ]
# Print the name of the current/working directory
pwd

#------------------------------------------------------------------------------#
002:017={Q}
#------------------------------------------------------------------------------#
002:018={R}

002:018={R}-[ realpath ]
# Find the real file path to a specified file or folder
# Install with the following command:
sudo apt-get install realpath
# Proper syntax for realpath on example file named "MyFile.txt"
# While located in the same directory as "MyFile.txt", use the command:
realpath MyFile.txt
# Example output in the terminal after you run the command above
{OUTPUT}[/var/www/public_files/MyFile.txt]

002:018={R}-[ rm ]
# Delete, or "remove" files with the "rm" tool
# See section 001:006={DELETING FILES}

002:018={R}-[ route ]
# Display the system kernel's IP routing table with the following command:
route
# View the same table with IP addresses instead of gateway names with this command:
route -n

002:018={R}-[ rsync ]
# Synchronize one directory with another
# NOTE: This command works across SSH and remote connections as well as local files/folders
rsync

#------------------------------------------------------------------------------#
002:019={S}
#------------------------------------------------------------------------------#
002:020={T}

002:020={T}-[ tar ]
# Unpack .xz and .tgz archives with tar
# Most packages can be unpacked using the "-xf" flag with tar like this:
tar -xf ARCHIVE.tar.xz
# The -xf flag works with a large number of compression types. So basically, if in doubt, just use the -xf flag with tar.
# NOTE: Make sure that you have the additional utilities installed for tar (xz-utils).
# Unpack the .gzip and .bzip2 archive types with the tar command:
tar -xfz ARCHIVE.gzip
tar -xfz ARCHIVE.bzip2

002:020={T}-[ tree ]
# Display the system file structure as a tree
# Install "tree" with the following:
sudo apt-get install tree
# Now run the tree program with the following command to output the results into an HTML file:
tree -H ./ > result.html
# View the "result.html" tree:
xdg-open result.html

#------------------------------------------------------------------------------#
002:021={U}

002:021={U}-[ unrar-free ]
# Unpack a .rar archive with the "unrar" tool. First install it with the following command:
sudo apt-get install unrar-free
# Now unpack the archive (Example archive named: "ARCHIVE.rar") with this command:
unrar e ARCHIVE.rar

#------------------------------------------------------------------------------#
002:022={V}
#------------------------------------------------------------------------------#
002:023={W}

002:023={W}-[ wc ]
# The "wc" program is excellent for comparing versions of files, among other things.
# To search a text document named "awesome.txt" with this tool, run the following command:
wc awesome.txt
# The output will include three number sets which correspond to the following:
{OUTPUT}: [# of new lines] [# of words] [# of characters]
# To learn more about this tool, read the documentation at the following location: 
{URL}: "http://manpages.ubuntu.com/manpages/trusty/man1/wc.1.html"

002:023={W}-[ wget ]
# Use the wget tool to copy, download, or mirror entire websites. 
# Download site with links not adjusted for static use, which means, all internal hyperlinks on 
# the site will point to their original locations online.
wget -m https://example.com
# Download the site with links adjusted to reference the other files downloaded, allowing for easy
# offline and local viewing of the site:
wget -m -k https://example.com
# To avoid flagging your IP address on the servers of the site that you are scraping, add a 
# "wait time" in between the requests being sent with the "-w" flag like this:
wget -m -k -w 5 https://example.com/
# Note that the number ("5") in the example above is the number of seconds to wait. This can be
# adjusted to minutes by appending the suffix of "m" for minutes, "h" for hours, or "d" for days.

002:023={W}-[ whereis ]
# The following command shows how you would look for a file named "MyFile":
whereis MyFile

002:023={W}-[ whoami ]
# Print the name of the user that you are currently controling
whoami

#------------------------------------------------------------------------------#
002:024={X}

002:024={X}-[ xmlstarlet ]
# Perform many different operations on XML file types using the terminal tool, xmlstarlet.
# Install with the following command:
sudo apt-get install xmlstarlet
# Generate plain text table from XML document
xml sel -T -t -m /xml/table/rec -v "@id" -o "|" -v numField -o "|" -v stringField -n xml/table.xml
Result Output:
1|123|String Value
2|346|Text Value
3|-23|stringValue
# Generate plain text table from XML document
xml sel -T -t -m /xml/table/rec -v "concat(@id,'|',numField,'|',stringField)" -n xml/table.xml
Result Output:
1|123|String Value
2|346|Text Value
3|-23|stringValue
# Generate plain text table from XML document
xml sel -T \
    -t -o "===================" -n \
       -m xml/table/rec -v "concat(@id,'|',numField,'|',stringField)" -n \
    -t -o "===================" -n xml/table.xml
Result Output:
===================
1|123|String Value
2|346|Text Value
3|-23|stringValue
===================

002:024={X}-[ xz-utils ]
# Unpack a .xz archive with the tar command. First make sure you have the necessary utility package installed by running the following command: 
sudo apt-get install xz-utils
# Now complete the job of unpacking the archive ("ARCHIVE.tar.xz") as follows:
tar -xf ARCHIVE.tar.xz
# The -xf flag works with a large number of other compression types as well. So basically, if in doubt, just use the -xf flag with tar.

#------------------------------------------------------------------------------#
002:025={Y}
#------------------------------------------------------------------------------#
002:026={Z}
#------------------------------------------------------------------------------#
################################################################################
003={SYSTEM ADMINISTRATION AND EXPLOITATION}
################################################################################
#------------------------------------------------------------------------------#
003:001={PERMISSIONS AND USER ACCESS}

003:001:001={ADD A NEW USER}
# Add a new user (or add a series of new users) to your system
sudo adduser username1 username1 username3

003:001:002={PRINT YOUR USERNAME IN THE TERMINAL}
whoami

003:001:003={DISCOVER WHAT USER GROUPS EXIST}
groups

003:001:004={DISCOVER USER GROUP MEMBERSHIPS}
# Print the groups in which bob is a member
groups bob

003:001:005={FIND OWNER AND GROUP OF A DIRECTORY}
sudo ls -l /path/to/file
# such that the third column of the output is the owner (user) and the fourth column of the output is the group

003:001:006={GIVE USER OWNERSHIP OF A DIRECTORY}
sudo chown -R username directory

003:001:007={GIVE FULL READ/WRITE PERMISSIONS}
sudo chmod -R u+rX directory

003:001:008={MAKE A FILE ("MyScript.File") EXECUTABLE}
sudo chmod +x MyScript.File

003:001:009={VIEW ALL USER ACCOUNTS ON THE SYSTEM}
compgen -u
# The following command will also perform this function but is said by some to be more thorough
sudo getent passwd

003:001:010={VIEW ALL USER-GROUPS ON THE SYSTEM}
compgen -g
# Also the following:
sudo getent group
#------------------------------------------------------------------------------#
003:002={SYNCRONIZE ONE DIRECTORY WITH ANOTHER}
# NOTE: This command works across SSH and remote connections as well as local files/folders
rsync
#------------------------------------------------------------------------------#
003:003={VIEW ALL RUNNING PROCESSES}
#-> METHOD 1
watch -n 1 'ps -e -o pid,uname,cmd,pmem,pcpu --sort=-pmem,-pcpu | head -15'
# Table is constant and sorts processes by system load via the 'ps' command
# coupled with the 'watch' command. By default this watches the top 15 processes.
# To watch the top 25 system-heavy processes, use the following:
watch -n 1 'ps -e -o pid,uname,cmd,pmem,pcpu --sort=-pmem,-pcpu | head -25'
#-> METHOD 2
# Simply run the following command: 
top
# While the output is live and continuous, it tends to not be as formatted and can sometimes
# print in an unstable or unusual manner.
#-> METHOD 3
# The more graphical version of "top" is called "htop". 
# Install htop with the following command:
sudo apt install htop
# Then run htop with the command:
htop
# You can kill/end processes graphically using htop! Simply refer to the options displayed at the bottom of the terminal screen
#------------------------------------------------------------------------------#
003:004={LIST SYSTEM HARDWARE}
# List all hardware installed on your system
# NOTE: You need to run this command with "sudo" permissions
sudo lshw
# See also: lynx
# lynx is a useful text-only terminal-based web browser
# (AFTER INSTALL) run lynx with the following command: 
lynx
# Dump all links from a single webpage with Lynx
lynx -listonly -dump url.example.com
# Output the result of the link list dump into a text file in your current directory
lynx -listonly -dump url.example.com | nano url.example.com.txt
#------------------------------------------------------------------------------#
003:005={SCHEDULING TASKS WITH CRON}
# cron is the tool which automates things for you
# crontab is the tool which dictates the actions of cron (for each system user)
# List the contents of the crontab file (if contents exist):
crontab -l
# Edit the contents of the crontab file:
crontab -e
# Remove the contents of the crontab file:
crontab -r
# Edit the contents of a DIFFERENT user's crontab file (where "OTHERUSER" is the username of the user whose crontab file you will be editing):
crontab -e -u OTHERUSER
# Please note that you must be an administrative user to edit the crontab files of other users.
# The crontab file contains entries which describe the processes to be automated. These entries each begin with FIVE specific elements of TIME:
> (MINUTE): 0-59
> (HOUR): 0-23 with 0 being 12:00 AM
> (DAY OF THE MONTH): 1-31
> (MONTH): 1-12
> (DAY OF THE WEEK): 0-6 with 0 being Sunday
# Below is a series of example crontab entry time codes with corresponding definitions:
# Daily at 11:00 PM
0 23 * * *
# Daily at 10:30 PM
30 22 * * *
# Every first day of the month at 11 PM
0 23 1 * *
# Every Sunday at 11PM
0 23 * * 0
# The FreeBSD implementation of cron introduced the useful shortcuts which can be used instead of the afforementioned FIVE-part time elements. These shortcuts are listed below:
#-> @reboot (Run once, at startup of cron)
#-> @yearly (Run once a year, "0 0 1 1 *")
#-> @annually (same as @yearly)
#-> @monthly (Run once a month, "0 0 1 * *")
#-> @weekly (Run once a week, "0 0 * * 0")
#-> @daily (Run once a day, "0 0 * * *")
#-> @midnight (same as @daily)
#-> @hourly (Run once an hour, "0	* * * *")
#-> @every_minute (Run once a minute, "*/1 * * * *")
#-> @every_second (Run once a second)
# To add a new automated process to cron, you must first select or create a shell script (a file ending in  .sh) which contains the instructions needed for the desired process. That script file will then be saved (as a hidden file so as to protect it). Make sure that your script is executable by running the following command: 
chmod u+x ~/.MyScript.sh
# Assuming you have a shell script with the name "MyScript.sh" located in your user's home directory, you could run this script in cron by adding the following entry to crontab:
0 23 * * * ~/.MyScript.sh
#------------------------------------------------------------------------------#
003:006={CHECK YOUR IP ADDRESS}
# Find out your current public IP address by using curl on the Google domain tool for checking your IP address. Use the following command:
curl https://domains.google.com/checkip && echo ' '
# Create a shortcut for this process:
alias checkip='curl https://domains.google.com/checkip && echo " -- "`date`'
# After creating this shortcut, you can check your system IP address with the following:
checkip
# The output will look like this:
{OUTPUT}: 192.168.0.1 -- Mon Jan 01 08:31:49 EDT 2017
#------------------------------------------------------------------------------#
003:007={NETWORK CONNECTIONS}
# Get a general overview of the network status for your system
netstat
# List all active ports and connections (external)
netstat -tunlp
# List all active ports and connections (internal & external)
netstat -pln
# Use a full network analysis tool to see what IPs are connected to the local network
# Install arp-scan with the following
sudo apt-get install arp-scan
# Run a scan on the local network with the following command:
sudo arp-scan --localnet
# If connected to the local network via multiple network interfaces or connections, specify the
# one you wish to use for the arp-scan with the --interface flag like this:
sudo arp-scan --interface=eth0 --localnet
# To discover which interface you are using to interact with the local network
# run the following command
ifconfig
# Learn more about the arp-scan tool at the following address: 
{URL}: "http://manpages.ubuntu.com/manpages/zesty/en/man1/arp-scan.1.html"
# List Process IDs with corresponding port numbers and what external IP addresses are connected to them
lsof -i -P
# View the kernel IP routing table:
# Display the system kernel's IP routing table with the following command:
route
# View the same table with IP addresses instead of gateway names with this command:
route -n
#------------------------------------------------------------------------------#
003:008={NETWORK AND PORT MAPPING}
# (AFTER INSTALL) run nmap with the following command:
nmap
# Scan the open ports and status of a specific IP address (this example uses the IP address
# of 192.168.1.50 as an example) with the following command: 
nmap 192.168.1.50
# NOTE: In many jurisdictions it is illegal to scan the ports of systems which you don't control.
# Hackers are able to maintain a level of annonymity by spoofing their MAC address during a port
# scan by using the --spoof-mac flag like this:
nmap -spoof-mac 00:11:22:33:44:55 192.168.1.50
# By spoofing your MAC address you are able to assume the identity of another trusted
# computer on the target network (if you know the MAC address of any of the authorized computers)
# or, at the very least, you are able to distance yourself from using the true identity of your own
# computer. (The example above uses the false MAC address, 00:11:22:33:44:55).
# Output the results of your nmap scan to a text file ("scan.txt")
nmap -oN scan.txt 192.168.1.50
# Print the output to a text file while spoofing your MAC address:
nmap -spoof-mac 00:11:22:33:44:55 -oN scan.txt 192.168.1.50
#------------------------------------------------------------------------------#
003:009={SECURE SHELL FOR REMOTE ACCESS}
# Secure shell, known as SSH, is a powerful tool which you can use to control other computers
# located outside of your local network. To use this tool you must first generate a new key (if it
# is your first time using SSH). Key generation occurs with the related tool:
ssh-keygen
# Full syntax for the creation of a new ssh key is depicted below. Notice that the -C flag is used
# to generate a user name comment in the keyfile:
ssh-keygen -t rsa -f ~/.ssh/[USERKEY] -C [USER]
# Now configure the ssh client to use the newly generated keyfile 
ssh-rsa [USERKEY] [USER]
# In addition to these steps, it is also recommended that you restrict access to the remote
# connection with the following resource:
chmod 400 ~/.ssh/[KEYFILE]
#------------------------------------------------------------------------------#
003:010={DISPLAY LOCAL DNS INFORMATION}
#
cat /etc/resolv.conf
#------------------------------------------------------------------------------#
003:011={DISPLAY LOCAL GATEWAY INFORMATION}
ip r
# Additionally, you can use the following command in netstat:
netstat -r -n
#------------------------------------------------------------------------------#
003:012={}
#------------------------------------------------------------------------------#
003:013={}
#------------------------------------------------------------------------------#
003:014={}
#------------------------------------------------------------------------------#
003:015={}
#------------------------------------------------------------------------------#
003:016={}
#------------------------------------------------------------------------------#
003:017={}
#------------------------------------------------------------------------------#
003:018={}
#------------------------------------------------------------------------------#
003:019={}
#------------------------------------------------------------------------------#
003:020={}
#------------------------------------------------------------------------------#
003:021={}
#------------------------------------------------------------------------------#
003:022={}
#------------------------------------------------------------------------------#
003:023={}
#------------------------------------------------------------------------------#
003:024={}
#------------------------------------------------------------------------------#
003:025={}
#------------------------------------------------------------------------------#
003:026={}
#------------------------------------------------------------------------------#
################################################################################
004={FRAMEWORKS AND LIBRARIES}
################################################################################
#------------------------------------------------------------------------------#
004:001={WORKING WITH PPAs}

004:001:001={ADD A NEW PPA}
sudo add-apt-repository ppa:PPA_NAME/ppa

004:001:002={LIST ALL PPAs ADDED TO YOUR SYSTEM}
sudo ls /etc/apt/sources.list.d

004:001:003={REMOVE PPA FROM UPDATE SOURCES}
#-> METHOD 1
# NOTE: Does not remove any software
sudo add-apt-repository --remove ppa:PPA_NAME/ppa
#-> METHOD 2
# NOTE: Does not remove any software
sudo rm -i /etc/apt/sources.list.d/PPA_NAME.list

004:001:004={REMOVE PPA FROM SOURCES AND UNINSTALL SOFTWARE}
# Install the ppa-purge tool
sudo apt-get install ppa-purge
# Use the ppa-purge tool with this command
sudo ppa-purge ppa-url
# NOTE: The URL of the PPA you wish to purge can be found in your sources list
#------------------------------------------------------------------------------#
004:002={BUILDING AND USING SHELL SCRIPTS}

004:002:001={RUN SHELL SCRIPTS}
> METHOD 1
# Once you are in the correct current folder you can run the script like this:
./script1.sh
# or you can run and redirect the output to a file:
./script1.sh > out.txt
# or you can filter the output for keywords (e.g. "apples") an then redirect to a file:
./script1.sh | grep apples > ./only-apples
# There are thousands of things you can to to that file just by typing a few commands.
# Another one, you can download a file from the Internet with one simple command:
wget www.google.com/images/logos/ps_logo2.png
# And then open the file like this:
shotwell ps_logo2.png
> METHOD 2
# Give execute permission to your script:
chmod +x /path/to/yourscript.sh
# And to run your script:
/path/to/yourscript.sh
# Since . refers to the current directory: if yourscript.sh is in the current 
# directory, you can simplify this to:
./yourscript.sh

004:002:002={SHELL SCRIPT SYNTAX CONSIDERATIONS}
# Always begin a new script file with the following opening line (including the hashtag "#"):
#! /bin/bash
# Be very careful to avoid unintentionally leaving white space
# Pay attention to every last detail as the smallest mistake can cause the script to not function

004:002:003={OPENING FILES LOCALLY}
# One feature of a script that is often overlooked is portability. In order to be able to use a
# script on a different system it is important to not lock your script into an unflexible 
# configuration. Keep the script flexible by using the following function on files you wish to
# interact with:
realpath MyFile.txt
# Be sure to verify that realpath is installed on the system as a dependancy first. 
# By using realpath you can discover the full path of a desired file which can then be referenced
# to open in the browser or other software. The catch-all opening function is as follows:
xdg-open
# Couple this command with realpath like this:
xdg-open `realpath MyFile.txt`

004:002:004={DEFINE AND ACCESS VARIABLES}
# A variable assignment has the form of a variable name, followed by the equal sign, followed by 
# the (optional) value. The following example is a valid variable assignment:
ABC=123
# To access the value stored in a variable, prefix its name with the dollar sign ($)
# The following script will output the result: "h8rt3rmin8r"
NAME="h8rt3rmin8r"
echo $NAME
# Consider these additional options
# NOTE: The "declare" and "let" functions are only available in the bash shell
# "eval" executes arbitrary commands.
# If on the right side of the equal sign you have a variable that expands to some command, that 
# command will be executed. The following code is equivalent to a=hello.
x=a
y='$(echo hello)'
eval "$x=$y"
# "declare" is a bash function to assign variables and won't execute any command. 
# The following code is equivalent to a='$(echo hello)'.
x=a
y='$(echo hello)'
declare "$x=$y"
# "let" is similar to "declare", in that it doesn't execute commands. 
# However, unlike "declare", "let" may be used for arithmetic operations.
# The following code is equivalent to a=3
let a="1 + 2"

004:002:005={BUILD A STRING FROM VARIABLE INPUTS}
# Example (1):
var="${var}string"
# Example (2):
# Using concatenation to combine variables into the name of a file
NAME=$(echo ${FILENAME}_${EXTENSION})
# Example (3):
_p="/delta"
_u="aqua"
    # [... now join the two $vars]
out="${_p}${_u}"
echo "${_p}${_u}"
echo "${_p} and ${_u}"
echo "${_p}/${_u}"
echo "Output: $out"

004:002:006={REFERENCE LINES IN A TEXT FILE TO BE USED IN A CURL FUNCTION}
# Use lines from a source text file as inclusions in a curl function
cr=$'\r'
while read line
do
    line="${line%$cr}"
    curl "https://gdata.youtube.com/feeds/api/users/${line}/subscriptions?v=2&alt=json" \
         > "/home/user/archive/$line"
done < textfile.txt

004:002:007={CORRECT USE OF CURLY BRACKETS}
# Use ${ } to enclosure a variable.
# Without curly brackets:
VAR="foo"
echo $VAR
echo $VARbar
# would give
foo
# ...and nothing else because the variable $VARbar doesn't exist.
# With curly brackets:
VAR="foo"
echo ${VAR}
echo ${VAR}bar
# would give
foo
foobar
# Enclosing the first $VAR is not necessary, but a good practice.
# See the sample script below: 
#!/bin/sh
WEBSITE="danydiop" 
/usr/bin/mysqldump --opt -u root --ppassword ${WEBSITE} > ${WEBSITE}.sql

004:002:008={DIALOGUE BOXES}
# Use dialogue boxes located inside the terminal to interact with the users of your script
# First download the package which enables this feature (make sure that you include this in your
# script's dependencies listing as well). Install with the following command:
sudo apt-get install dialog
# Build a script which uses this feature like this: 
if (dialog --title "Fun Checker"  --yesno "Are you having fun?" 6 25)
then echo "glad you are having fun!"
else echo "well that sucks..."
fi

#------------------------------------------------------------------------------#
004:003={PROGRAM CROSS-PLATFORM SOFTWARE WITH MONO}
# Add Mono development packages to Ubuntu
sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 
3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF
echo "deb http://download.mono-project.com/repo/ubuntu xenial main" | 
sudo tee /etc/apt/sources.list.d/mono-official.list
sudo apt-get update
sudo apt-get install mono-devel
# Install the MonoDevelop IDE
sudo apt-get update
sudo apt-get install monodevelop
# Use the Mono IDE 'MonoDevelop"
monodevelop
# Create your first ASP.NET program
# Read the short tutorial here: 
{URL}: "http://www.monodevelop.com/documentation/creating-aspnet-projects/"
#------------------------------------------------------------------------------#
004:004={VISUALIZE DATA WITH GRAPHVIZ-DEV}

004:004:001={BASIC INFORMATION}
# Project Website
{URL}: "http://www.graphviz.org/"
# Live web-version
{URL}: "http://www.webgraphviz.com/"
# Launchpad Profile
{URL}: "https://launchpad.net/~gviz-adm/+archive/ubuntu/graphviz-dev"

004:004:002={INSTALLING GRAPHVIZ}
# NOTE: Do not use the instructions located on the Graphviz website for installing the program
# onto an Ubuntu system. The instructions are outdated and have many errors. Instead, use the 
# official Ubuntu implementation of graphviz by installing with the following command:
sudo apt-get install graphviz-dev
# Program files are automatically installed into the following locations on your system:
/usr/lib/graphviz 
/usr/include/graphviz

004:004:003={LEARN TO DRAW FOR GRAPHVIZ}
# Graphviz (and the xdot tool below) read/write files called "dot" files. 
# Here is the official guide to creating and working with dot files:
{URL}: "http://www.graphviz.org/Documentation/dotguide.pdf"

004:004:004={ADDITIONAL FEATURES IN THE xdot TOOL}
# You can also add the additional graphical features available in the xdot tool
# xdot can read and explore files created by graphviz. Get xdot here:
{URL}: "https://apps.ubuntu.com/cat/applications/natty/xdot/"
#------------------------------------------------------------------------------#
004:005={NODE.JS AND NODE PACKAGE MANAGER}

004:005:001={NODE.JS INTRODUCTION}
# SOURCE: https://nodejs.org/en/
# node.js is a JavaScript runtime built on Chrome's V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. 
# Node.js' package ecosystem, npm, is the largest ecosystem of open source libraries in the world.

004:005:001={NODE PACKAGE MANAGER INTRODUCTION}
# SOURCE: https://www.npmjs.com/
# npm is the package manager for JavaScript and the worlds largest software registry. 
# Discover packages of reusable code  and assemble them in powerful new ways.

004:005:001={INSTALLING NODE.JS}
# To install node.js on Ubuntu, Debian, or similar system, use the following commands: 
curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -
sudo apt-get install -y nodejs
# Then install the additional tools for node.js with the following: 
sudo apt-get install -y build-essential
# Check the version of node.js that you are running with the following command: 
node -v

004:005:001={INSTALLING NPM}
# npm is automatically installed on your system when you install node.js
# Check the version of npm that you are running with the following command: 
npm -v
# npm automatically updates when you update your system. However, you can force npm to check for updates with the following command:
npm install npm@latest -g

004:005:001={IMPORTANT NOTE ABOUT PERMISSIONS}
# Many users experience permissions errors while using npm and node.js. While this can be a frustrating experience, it is easily resolved with the following method found at this location:
URL: https://docs.npmjs.com/getting-started/fixing-npm-permissions
# In brief, the fix uses the following steps: 
#-> Find the path to node's directory like this: 
npm config get prefix
#-> For many systems, this will be /usr/local If your system does not return this as the directory then DO NOT use this method as you will mess up further permission configurations on your system
# Moving forward, change the owner of npm's directories to the name of the current user (your username!) with the following commands: 
sudo chown -R $(whoami) $(npm config get prefix)/{lib/node_modules,bin,share}
# This changes the permissions of the sub-folders used by npm and some other tools (lib/node_modules, bin, and share).
#------------------------------------------------------------------------------#
004:006={}
#------------------------------------------------------------------------------#
004:007={}
#------------------------------------------------------------------------------#
004:008={}
#------------------------------------------------------------------------------#
004:009={}
#------------------------------------------------------------------------------#
004:010={}
#------------------------------------------------------------------------------#
004:011={}
#------------------------------------------------------------------------------#
004:012={}
#------------------------------------------------------------------------------#
004:013={}
#------------------------------------------------------------------------------#
004:014={}
#------------------------------------------------------------------------------#
004:015={}
#------------------------------------------------------------------------------#
004:016={}
#------------------------------------------------------------------------------#
004:017={}
#------------------------------------------------------------------------------#
004:018={}
#------------------------------------------------------------------------------#
004:019={}
#------------------------------------------------------------------------------#
004:020={}
#------------------------------------------------------------------------------#
004:021={}
#------------------------------------------------------------------------------#
004:022={}
#------------------------------------------------------------------------------#
004:023={}
#------------------------------------------------------------------------------#
004:024={}
#------------------------------------------------------------------------------#
004:025={}
#------------------------------------------------------------------------------#
004:026={}
#------------------------------------------------------------------------------#
################################################################################
005={CRYPTOGRAPHY}
################################################################################
#------------------------------------------------------------------------------#
#
# AN INTRODUCTION TO CRYPTOGRAPHY:
# 
# The power of encryption is at the core of many of the most disruptive innovations in the modern world. It allows for the establishment of trust between computer users via mathematically provable methods of secure communications which cannot be decrypted or cracked by any party other than the intended recipiant(s). Thus, GPG is a tool which allows computer users to (among other things) establish a core digital identity.
# Many various tools exist which enable users to perform the mathematical operations of encryption and decryption. The GPG tool is commonly used for encypting documents in a Terminal (Mac, Linux) or PowerShell (on Windows).
#
#
#------------------------------------------------------------------------------#
005:001={GENERATE AND MANAGE AN IDENTITY}
# Begin by creating a new keypair. The following command will respond with prompts for information and then the GPG tool will create a new keypair for you
gpg --gen-key
# Print a list of all of the keys in your public keyring
gpg --list-keys
# Print a list of all keys in your public keyring and their associated signatures
gpg --list-sigs
# Print a list of all keys in your public keyring and their associated fingerprints
gpg --fingerprint
#------------------------------------------------------------------------------#
005:002={IMPORT, EXPORT, AND REFRESH KEYS}
# Import a key contained in the file named "KeyFile" and add it to your keyring:
gpg --import KeyFile
# Receive the key which corresponds to KeyID1, KeyID2, etc from the provided keyserver
gpg recv-keys KeyID1 KeyID2
# Search for keys which contain Term1 and Term2, etc. This function provides an interactive interface to choose the correct key to import to your keyring:
gpg --search-keys Term1 Term2
# Export a key into a public key text file for others to use in the process of identifying you and communicating with you:
gpg --export -a KEYID > publickey.asc
# You can send the publickey.asc via email or other means, or you can upload your public identity
# key onto a public key server with the following command:
gpg --send-keys KeyID
# Refresh your keys to check if any of them are expired:
gpg --refresh-keys
#------------------------------------------------------------------------------#
005:003={SIGN A FOREIGN GPG KEY}
# Signing a key is a public way of stating that you have verified the validity of a specific key
# The first thing you must do is check the local key fingerprint against the reported fingerprint:
gpg --fingerprint UniqueID
# If the fingerprints match sign the key with your private key
gpg --sign-key UniqueID
#------------------------------------------------------------------------------#
005:004={ASYMMETRIC ENCRYPTION WITH GPG}
# Encrypting items with the GPG tool is quite simple. These are the two types of items which you can encrypt with this tool:
    > File (A named file of any type and any size containing any form of information.)
    > Text (Typed text of any kind or length, typed into the Terminal at the time of encryption.)
    > Text inside of a File (... this is self explanitory)
# In addition to encrypting files and text, you can (and should most likely should) also sign the items which you encrypt so that your intended recipient(s) can verify the items came from you.
# The following command produces "MyFile.gpg" which is an encrypted version of "MyFile". This new file can only be decrypted by the specified "Recipient".
gpg -er Recipient MyFile
# The following command produces an encrypted version of "MyText" which can only be decrypted by the specified "Recipient". The output of this command prints into the terminal display.
echo MyText | gpg -ear Recipient
# The following command produces an encrypted version of "MyText" which can only be decrypted by the specified "Recipient". The output of this command writes to "OutFile".
echo MyText | gpg -ear Recipient > OutFile
# The following command produces an encrypted version of the text contained in "InFile" which can only be decrypted by the specified "Recipient". The output of this command prints into the terminal display.
cat InFile | gpg -ear Recipient
# The following command produces an encrypted version of the text contained in "InFile" which can only be decrypted by the specified "Recipient". The output of this command writes to "OutFile".
cat InFile | gpg -ear Recipient > OutFile
# The following command produces "File.gpg" which is an encrypted and signed version of "MyFile", which can be decrypted and verified by the specified "Recipient".
gpg -esr Recipient MyFile
# The following command produces an encrypted and signed version of "MyText" which can be decrypted and verified by the specified "Recipient". The output of this command prints into the terminal display.
echo Text | gpg -esar Recipient MyFile
# The following command produces an encrypted and signed version of "MyText" which can be decrypted and verified by the specified "Recipient". The output of this command writes to "OutFile".
echo Text | gpg -esar Recipient MyFile > OutFile
# The following command produces an encrypted and signed version of the text in "InFile" which can be decrypted and verified by the specified "Recipient". The output of this command prints into the terminal display.
cat InFile | gpg -esar Recipient
# The following command produces an encrypted and signed version of the text in "InFile" which can be decrypted and verified by the specified "Recipient". The output of this command writes to "OutFile".
cat InFile | gpg -esar Recipient > OutFile
#------------------------------------------------------------------------------#
005:005={ASYMMETRIC DECRYPTION WITH GPG}
# Decrypt and/or verify File
gpg -d InFile > OutFile
# Decrypt and/or verify Cipher Text
echo Cipher Text | gpg -d
# Decrypt and/or verify Cipher Text and write the result to OutFile
echo Cipher Text | gpg -d > OutFile
# Decrypt and/or verify the contents of File
cat InFile | gpg -d
# Decrypt and/or verify the contents of File and write the result to OutFile
cat InFile | gpg -d > OutFile
#------------------------------------------------------------------------------#
005:006={SYMMETRIC ENCRYPTION}
# Create a file symmetrically encrypted with a passphrase
gpg -c File
# Create a file symmetrically encrypted with a passphrase readable as plain text
gpg -ca File
# Symmetrically encrypt Test with a passphrase and output the result to the terminal
echo Text | gpg -ca
# Symmetrically encrypt Test with a passphrase and write the result to OutFile
echo Text | gpg -c > OutFile
# Symmetrically encrypt the text in InFile and output the result to the terminal
cat InFile | gpg -ca
# Symmetrically encrypt the text in InFile and write the result to OutFile
cat InFile | gpg -c > OutFile
#------------------------------------------------------------------------------#
005:007={}
#------------------------------------------------------------------------------#
005:008={}
#------------------------------------------------------------------------------#
005:009={}
#------------------------------------------------------------------------------#
005:010={}
#------------------------------------------------------------------------------#
005:011={}
#------------------------------------------------------------------------------#
005:012={}
#------------------------------------------------------------------------------#
005:013={}
#------------------------------------------------------------------------------#
005:014={}
#------------------------------------------------------------------------------#
005:015={}
#------------------------------------------------------------------------------#
005:016={}
#------------------------------------------------------------------------------#
005:017={}
#------------------------------------------------------------------------------#
005:018={}
#------------------------------------------------------------------------------#
005:019={}
#------------------------------------------------------------------------------#
005:020={}
#------------------------------------------------------------------------------#
005:021={}
#------------------------------------------------------------------------------#
005:022={}
#------------------------------------------------------------------------------#
005:023={}
#------------------------------------------------------------------------------#
005:024={}
#------------------------------------------------------------------------------#
005:025={}
#------------------------------------------------------------------------------#
005:026={}
#------------------------------------------------------------------------------#
################################################################################
006={WORKING WITH BLOCKCHAIN}
################################################################################
#------------------------------------------------------------------------------#
006:001={CHECK THE CURRENT BITCOIN PRICE}
# Check the final daily bitcoin prices (averaged via Coindesk Bitcoin Price Index). Response data is listed for the past month and updated daily.
curl https://api.coindesk.com/v1/bpi/historical/close.json | python -m json.tool
# Current BTC/USD exchange rate (as per the Coindesk Bitcoin Price Index)
curl https://api.coindesk.com/v1/bpi/currentprice/USD | python -m json.tool
#------------------------------------------------------------------------------#
006:002={OTHER USEFUL CRYPTOCURRENCY APIS}
# (OPTIONAL): The following commands can be shortened by creating an alias phrase (basically a shortcut variable) for the Python-powered json cleaning tool with the following command:
alias json-tool='python -m json.tool'
# Pull all currency pairs from Bittrex exchange and write them into a local file like this:
curl https://bittrex.com/api/v1.1/public/getcurrencies | python -m json.tool > bittrex-getcurrencies.json
# Check the top hashrates for the various assets connected to Minergate mining pool
# NOTE: (Assets included are XMR, XDN, BCN, AEON, and others)
curl https://api.minergate.com/1.0/pool/top/hashrate | python -m json.tool > minergate-thash.json
#------------------------------------------------------------------------------#
006:003={START WAVES MASTER NODE}
# Systemd users can start the node with 
sudo systemctl start waves.service 
# Please note: use "waves-testnet" for testnet in the previous command if you are going to be running on the Waves testnet.
# Enable autoload on start with 
sudo systemctl enable waves.service
# If you are using the systemd Waves node, you can view your live logs with the following command:
journalctl -u waves.service -f
#------------------------------------------------------------------------------#
006:004={UNINSTALL ETHEREUM}
# IMPORTANT NOTE: Before uninstalling any blockchain software, be sure to back up a copy of your keystore files if your wallet has any digital assets inside. Otherwise you will lose access to everything in your wallet. To uninstall the Mist browser/geth/wallet, use the following commands:
rm -rf ~/.config/Ethereum\ Wallet/
rm -rf ~/.config/Mist
rm -rf ~/.ethereum/geth
sudo rm -rf /opt/Ethereum\ Wallet
sudo rm -rf /opt/Mist
sudo rm -rf /usr/local/bin/ethereumwallet
sudo rm -rf /usr/local/bin/mist
# The following directory is the one which contains personal keys which allow the spending of digital assets. BACK UP THIS FILE BEFORE DELETION!
rm -rf .ethereum/keystore
#------------------------------------------------------------------------------#
006:005={}
#------------------------------------------------------------------------------#
006:006={}
#------------------------------------------------------------------------------#
006:007={}
#------------------------------------------------------------------------------#
006:008={}
#------------------------------------------------------------------------------#
006:009={}
#------------------------------------------------------------------------------#
006:010={}
#------------------------------------------------------------------------------#
006:011={}
#------------------------------------------------------------------------------#
006:012={}
#------------------------------------------------------------------------------#
006:013={}
#------------------------------------------------------------------------------#
006:014={}
#------------------------------------------------------------------------------#
006:015={}
#------------------------------------------------------------------------------#
006:016={}
#------------------------------------------------------------------------------#
006:017={}
#------------------------------------------------------------------------------#
006:018={}
#------------------------------------------------------------------------------#
006:019={}
#------------------------------------------------------------------------------#
006:020={}
#------------------------------------------------------------------------------#
006:021={}
#------------------------------------------------------------------------------#
006:022={}
#------------------------------------------------------------------------------#
006:023={}
#------------------------------------------------------------------------------#
006:024={}
#------------------------------------------------------------------------------#
006:025={}
#------------------------------------------------------------------------------#
006:026={}
#------------------------------------------------------------------------------#
################################################################################

###############################
###                         ###
### "think outside the box" ###
###   ($) \_()_/ ()    ###
###                         ###
###############################
